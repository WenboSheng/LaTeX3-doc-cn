\documentclass[full]{l3doc}
%latex3/l3kernel/expl3.dtx
\usepackage[UTF8, punct = kaiming, heading]{ctex}
\usepackage{graphicx}
\usepackage{hyperref}

\providecommand\acro[1]{\textsc{\MakeLowercase{#1}}}
\newenvironment{arg-description}{%
\begin{itemize}\def\makelabel##1{\hss\llap{\bfseries##1}}}{\end{itemize}}

% \title{^^A
%   The \textsf{expl3} package and \LaTeX3 programming^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released 2018-05-13}

\begin{document}
    
\title{\textsf{expl3} 宏包与 \LaTeX3 编程\footnotemark}
\author{\LaTeX3 项目组}
\date{发布于 2018-05-13}

\maketitle

\makeatletter
\def\@thefnmark{*}
\@footnotetext{
    这份文档是英文文档 \href{http://mirrors.ctan.org/macros/latex/contrib/l3kernel/expl3.pdf}{expl3.pdf} 的中文翻译。
    该手册简要介绍了 \LaTeX3 语法，是学习 \LaTeX3 语法以及更多进阶材料的必读文档。
    
    翻译过程中需要说明以下几点
    \begin{description}
        \item[convention] 这里指 \LaTeX3 提出的一整套新的代码格式（新语言），应当使用这种代码风格进行开发。翻译为“约定”。
        \item[interface] 一般情况下翻译为“接口”。
        \item[primitive] (e)\TeX{} 以及各引擎提供的基本命令（控制序列），翻译为“原始命令”。
        \item[token]  这是 \TeX{} 中的一个基本概念，然而确实很难找到一个确切的中文词汇与之对应。
        这里遵从zoho在 \href{https://github.com/CTeX-org/tex-impatient-cn/}{\emph{\TeX{} for the Impatient}} 等著作中的处理方式翻译为“记号”。
        进而“token list”翻译为“记号序列”。
        \item[register] 翻译为“寄存器”。
        \item[quark] \LaTeX3 中的新概念，暂时按照物理学中的称呼翻译为“夸克”。
    \end{description}
    
    本文档的地址为：\url{https://github.com/WenboSheng/LaTeX3-doc-cn/expl3-doc-cn}
    
    本文档可在 \LaTeX\ 项目公共协议（LPPL, \LaTeX\ Project Public License）下复制和分发。
    LPPL 协议的内容见 \url{http://www.latex-project.org/lppl/}。
    \begin{flushright}
        盛文博\\
        \href{mailto:wbsheng88@foxmail.com}{<wbsheng88@foxmail.com>}\\
        \today
    \end{flushright}
}%
\makeatother

% \begin{abstract}
\begin{abstract}

%
% This document gives an introduction to a new set of programming
% conventions that have been designed to meet the requirements of
% implementing large scale \TeX{} macro programming projects such as
% \LaTeX{}. These programming conventions are the base layer of \LaTeX3.
针对 \LaTeX{} 等大型 \TeX{} 宏编程项目对编程风格设计的需求，
本文介绍一套属于 \LaTeX3 的基础层面的全新程序设计约定。

%
% The main features of the system described are:
% \begin{itemize}
%   \item classification of the macros (or, in \LaTeX{} terminology,
%     commands) into \LaTeX{} functions and \LaTeX{} parameters, and also
%     into modules containing related commands;
%   \item  a systematic naming scheme based on these classifications;
%   \item  a simple mechanism for controlling the expansion of a function's
%     arguments.
% \end{itemize}
% This system is being used as the basis for \TeX{} programming within
% the \LaTeX3 project. Note that the language is not intended for either
% document mark-up or style specification. Instead, it is intended that
% such features will be built on top of the conventions described here.
该系统主要特性有：
\begin{itemize}
    \item 将宏（在 \LaTeX{} 术语中也称之为命令）分为 \LaTeX{} 函数和 \LaTeX{} 参数，
    并依照功能分为若干组模块；
    \item 基于这些分类提出了系统性的命名规则；
    \item 对于函数选项展开提出了简洁的控制机制。
\end{itemize}
该系统已经用于 \LaTeX3 项目中的 \TeX{} 程序设计基础。
请注意，该语言不是为了用在文档标记或者样式规范中，
而是为了构建其基础。

%
% This document is an introduction to the ideas behind the \pkg{expl3}
% programming interface. For the complete documentation of the programming
% layer provided by the \LaTeX3 Project, see the accompanying
% \texttt{interface3} document.
本文档简要介绍了 \pkg{expl3} 程序接口的主要思路。
关于\LaTeX3 编程层面的完整叙述，请参考配套的 \texttt{interface3} 文档。

%
% \end{abstract}
\end{abstract}

%
% \section{Introduction}
\section{简介}
%
% The first step to develop a \LaTeX{} kernel beyond \LaTeXe{} is to
% address how the underlying system is programmed.  Rather than the
% current mix of \LaTeX{} and \TeX{} macros, the \LaTeX3 system provides
% its own consistent interface to all of the functions needed to
% control \TeX{}.  A key part of this work is to ensure that everything
% is documented, so that \LaTeX{} programmers and users can work
% efficiently without needing to be familiar with the internal nature
% of the kernel or with plain \TeX{}.
%

在 \LaTeXe{} 之后，开发 \LaTeX{} 内核的第一步就是如何设计底层系统编程。
当前的情况是混合使用 \LaTeX{} 和 \TeX{} 宏。
与此不同的是，\LaTeX3 系统提供了自己的一套接口，用于控制 \TeX{} 所需的所有函数。
这项工作中关键的一部分就是确保所有的一切都是文档化的，
这样即便 \LaTeX{} 程序员和用户不熟悉内核机制或者 plain\TeX{}，也可以进行高效开发。

% The \pkg{expl3} bundle provides this new programming interface for
% \LaTeX{}. To make programming systematic, \LaTeX3 uses some very
% different conventions to \LaTeXe{} or plain \TeX{}. As a result,
% programmers starting with \LaTeX3 need to become familiar with
% the syntax of the new language.
%

\pkg{expl3} 宏集提供了新的 \LaTeX{} 程序设计接口。
为了使编程系统化，\LaTeX3 使用了与 \LaTeXe{} 或 plain \TeX{} 截然不同的程序风格约定。
因此，进行 \LaTeX3 开发需要熟悉这种全新的语法规则。

% The next section shows where this language fits into a complete
% \TeX{}-based document processing system.  We then describe the major
% features of the syntactic structure of command names, including the
% argument specification syntax used in function names.
%

下一节将展示，在一个完整的 \TeX{} 文档处理系统中，这项语言适用于哪些地方。
之后将描述命令名称的语法结构的主要特性，比如函数选项的语法规范。
然后将解释这种选项语法背后的实用思想，
同时也包括展开控制机制和定义不同形式函数的接口。
% The practical ideas behind this argument syntax will be explained,
% together with the expansion control mechanism and the interface
% used to define variant forms of functions.
%

我们将说明，
使用结构化的命名规则和多样化的函数形式能够极大提高代码的可读性以及可靠性。
此外，实践表明，新语法导致的长命令名不会明显加剧写代码开发的困难程度。

% As we shall demonstrate, the use of a structured naming scheme and of
% variant forms for functions greatly improves the readability of the
% code and hence also its reliability.  Moreover, experience has shown
% that the longer command names which result from the new syntax do not
% make the process of \emph{writing} code significantly harder.
%
% \section{Languages and interfaces}
\section{语言和接口}
%
% It is possible to identify several distinct languages related to the
% various interfaces that are needed in a \TeX{}-based document processing
% system.  This section looks at those we consider most important for
% the \LaTeX3 system.
%

在基于 \TeX{} 的文档处理系统中，
我们可以罗列出涉及到不同层面接口的各种语言。
本节将介绍在 \LaTeX3 中最重要的一些部分。

% \begin{description}
\begin{description}
%   \item[Document mark-up] This comprises those commands (often called
%     tags) that are to embedded in the document (the |.tex| file).
%
\item[文档标记] 包括文档（|.tex| 文件）中的一些命令，通常称为标签（tag）。

%     It is generally accepted that such mark-up should be essentially
%     \emph{declarative}. It may be traditional \TeX{}-based mark-up such
%      as \LaTeXe{}, as described in~\cite{A-W:LLa94} and~\cite{A-W:GMS94},
%     or a mark-up language defined via \acro{HTML} or \acro{XML}.
%
一种广泛接受的观点是，这样的标记本质上应当是\emph{声明式的（declarative）}。
它可以是传统的 \TeX{} 标记，比如~\cite{A-W:LLa94} 和~\cite{A-W:GMS94} 中描述的 \LaTeXe{}；
或者是通过 \acro{HTML} 或 \acro{XML} 定义的标记语言。

%     One problem with more traditional \TeX{} coding conventions (as
%     described in~\cite{A-W:K-TB}) is that the names and syntax of \TeX{}'s
%     primitive formatting commands are ingeniously designed to be
%     \enquote{natural} when used directly by the author as document mark-up
%     or in macros.  Ironically, the ubiquity (and widely recognised
%     superiority) of logical mark-up has meant that such explicit
%     formatting commands are almost never needed in documents or in
%     author-defined macros.  Thus they are used almost exclusively by
%     \TeX{} programmers to define higher-level commands, and their
%     idiosyncratic syntax is not at all popular with this community.
%     Moreover, many of them have names that could be very useful as
%     document mark-up tags were they not pre-empted as primitives
%     (\emph{e.g.}~\tn{box} or \tn{special}).
传统 \TeX{} 代码约定（如同~\cite{A-W:K-TB} 所描述的）的一大问题就是，
\TeX{} 确实精心而巧妙地设计了原始格式命令的名称和语法，
这样文档作者就可以在标记或宏中很“自然”地直接使用这些原始命令。
然而具有讽刺意味的是，无处不在的逻辑标记（这广泛认为是一大优势）
反而导致几乎没有必要在文档或自定义宏中直接使用这些原始格式命令。
几乎只有 \TeX{} 开发人员定义高层次命令时才使用原始命令，
而在社区中这种特殊的语法几乎是不流行的。
另外，原始命令占用了很多方便的名称（例如~\tn{box} 或 \tn{special}），
否则本可以像文档标记一样广泛使用的。

%
%   \item[Designer interface] This relates a (human) typographic
%     designer's specification for a document to a program that
%     \enquote{formats
%     the document}.  It should ideally use a declarative language that
%     facilitates expression of the relationship and spacing rules
%     specified for the layout of the various document elements.
%

\item[设计者接口] 该接口将文档的排版设计规范与“格式化文档”的程序联系起来。
理想状况下应当使用声明式的语言，这样可以更好地表达不同文档元素之间的布局关系和间距规则。

%     This language is not embedded in document text and it will be very
%     different in form to the document mark-up language.  For \LaTeX{},
%     this level was almost completely missing  from \LaTeX{}2.09; \LaTeXe{}
%     made some improvements in this area but it is still the case that
%     implementing a design specification in  \LaTeX{} requires far more
%     \enquote{low-level} coding than is acceptable.
%
这种语言没有嵌入到文档文本中，所以其形式与文档标记语言有很大不同。
对于 \LaTeX{}，在  \LaTeX{}2.09 中这一层次几乎完全是缺失的；
\LaTeXe{} 在这一领域做了一些改进，
然而在 \LaTeX{} 中实现一套设计规范仍然需要很多“低层次”编程，而这是不可接受的。

%   \item[Programmer interface]
%     This language is the implementation language within which the
%     basic typesetting functionality is implemented, building upon the
%     primitives of \TeX{} (or a  successor program).  It may also be used
%     to implement the previous two languages \enquote{within} \TeX{}, as in
%     the
%     current \LaTeX{} system.
\item[开发者接口]
这一语言构建在 \TeX{} 原始命令（或者后继程序）之上，并实现了基本排版功能。
它也用于“在\TeX{} 内”实现前两种语言，比如当前的 \LaTeX{} 系统就是这样。
%
% \end{description}
\end{description}

%
% The last layer is covered by the conventions described in this
% document, which describes a system aimed at providing a suitable
% basis for coding \LaTeX3. Its main distinguishing features are
% summarised here:
% \begin{itemize}
%   \item A consistent naming scheme for all commands, including \TeX{}
%     primitives.
%   \item The classification of commands as \LaTeX{} functions or \LaTeX{}
%     parameters, and also their division into modules according to their
%     functionality.
%   \item A simple mechanism for controlling argument expansion.
%   \item Provision of a set of core \LaTeX{} functions that is sufficient
%     for handling programming constructs such as queues, sets, stacks,
%     property lists.
%   \item A \TeX{} programming environment in which, for example, all
%     white space is ignored.
% \end{itemize}

本文档描述的语法约定覆盖最后一个层面，
这一系统旨在提供一个合适的 \LaTeX3 编程基础。
主要突出的特点总结如下：
\begin{itemize}
\item 为所有命令提供相容的命名机制，包括 \TeX{} 原始命令。
\item 将命令分为 \LaTeX{} 函数或 \LaTeX{} 参数，同时也根据功能分为若干模块。
\item 为选项展开提出简洁的控制机制。
\item 提供一组 \LaTeX{} 核心函数，可以处理队列、集合、栈、属性列表等程序组件。
\item \TeX{} 编程环境。比如在其中所有的空格都会被忽略。
\end{itemize}

%
% \section{The naming scheme}
\section{命名机制}
%
% \LaTeX3 does not use |@| as a \enquote{letter} for defining
% internal macros.  Instead, the symbols |_| and |:|
% are used in internal macro names to provide structure. In
% contrast to the plain \TeX{} format and the \LaTeXe{} kernel, these
% extra letters are used only between parts of a macro name (no
% strange vowel replacement).

\LaTeX3 没有使用 |@| 作为定义内部宏的“字母”，
取而代之的是使用符号 |_| 和 |:| 来表现结构。
与 plain\TeX{} 格式和 \LaTeX{} 内核不同，
这些额外的字母只能用在宏名称的各部分之间（没有奇怪的元音替换）。

%
% While \TeX{} is actually a macro processor, by
% convention for the \pkg{expl3} programming language we distinguish between
% \emph{functions} and \emph{variables}. Functions can have arguments and they
% are either expanded or executed.  Variables can be assigned values and they
% are used in arguments to functions; they are not used directly but are
% manipulated by functions (including getting and setting functions).
% Functions and variables with a related functionality (for example accessing
% counters, or manipulating token lists, \emph{etc.})\ are collected together
% into a
% \emph{module}.
%
虽然说 \TeX{} 实际上是宏处理器，
不过按照 \pkg{expl3} 程序语言的约定，我们还是区分\emph{函数}和\emph{变量}这两个概念。
函数可以带有可展开或者立即执行的选项。
变量可以被赋值，用于函数的选项；
变量不会直接使用，而是通过函数进行操作（包括获取函数和设置函数）。
具有相关功能的函数和变量（例如使用计数器、或者操作记号列表等）被归纳在一起组成一个\emph{模块}。

% \subsection{Examples}
\subsection{例子}
%
% Before giving the details of the naming scheme, here are a few typical
% examples to indicate the flavour of the scheme; first some variable
% names.
% \begin{quote}
%   \cs{l_tmpa_box} is a local variable (hence the~|l_| prefix)
%     corresponding to a box register.\\
%   \cs{g_tmpa_int} is a global variable (hence the~|g_| prefix)
%     corresponding to an integer register (i.e.~a \TeX{} count
%     register).\\
%   \cs{c_empty_tl} is the constant~(|c_|) token list variable
%     that is always empty.
% \end{quote}
在给出命名机制的细节之前，这里列出一些典型例子来说明该机制的风格；
首先是一些变量名
\begin{quote}
    \cs{l_tmpa_box} 是对应于盒子寄存器的局部变量（这里的~|l_| 前缀代表局部）。\\
    \cs{g_tmpa_int} 是对应于整型寄存器（即 \TeX{} 计数寄存器）的全局变量（这里的~|g_| 前缀代表全局）。\\
    \cs{c_empty_tl} 是常值（|c_|）记号列表变量，并且总是空的。
\end{quote}
%
% Now here is an example of a typical function name.
接下来是一个典型的函数名称例子。

%
% \cs{seq_push:Nn} is the function which puts the token list specified
% by its second argument onto the stack specified by its first argument.
% The different natures of the two arguments are indicated by the~|:Nn|
% suffix. The first argument must be a single token which \enquote{names}
% the stack parameter: such single-token arguments are denoted~|N|.
% The second argument is a normal \TeX{} \enquote{undelimited argument},
% which
% may either be a single token or a balanced, brace-delimited token
% list (which we shall here call a \textit{braced token list}): the~|n|
% denotes such a \enquote{normal} argument form. The name of the function
% indicates it belongs to the |seq| module.
%
\cs{seq_push:Nn} 是一个函数，将由第二个选项确定的记号列表放入由第一个选项确定的栈中。
两个选项的不同之处由后缀~|:Nn| 指定。
第一个选项必须是一个单记号，用以命名栈参数：这样的单记号选项记为~|N|。
第二个选项是常规的 \TeX{} “未限定选项”，可以是单记号或者限定在配对大括号中的记号列表
（这里我们称之为\emph{带括号的记号列表}）：
后缀~|n| 说明是“常规（normal）”的选项形式。
函数名说明它属于 |seq| 模块。

% \subsection{Formal naming syntax}
\subsection{正式的命名语法}
%
% We shall now look in more detail at the syntax of these names. A
% function name in \LaTeX3 has a name consisting of three parts:
% \begin{quote}
%   |\|\meta{module}|_|\meta{description}|:|\meta{arg-spec}
% \end{quote}
% while a variable has (up to) four distinct parts to its name:
% \begin{quote}
%   |\|\meta{scope}|_|\meta{module}|_|\meta{description}|_|\meta{type}
% \end{quote}

现在我们详细地看一下这些名称的语法。
\LaTeX3 中的函数名包括三部分：
\begin{quote}
    |\|\meta{模块module}|_|\meta{描述description}|:|\meta{选项规范arg-spec}
\end{quote}
而变量名（至多）有四部分：
\begin{quote}
    |\|\meta{作用域scope}|_|\meta{模块module}|_|\meta{描述description}|_|\meta{类型type}
\end{quote}

%
% The syntax of all names contains
% \begin{quote}
%   \meta{module} and \meta{description}
% \end{quote}
% these both give information about the command.

所有的名称语法都包含
\begin{quote}
    \meta{模块module} 和 \meta{描述description}
\end{quote}
这两部分给出了命令的信息。

%
% A \emph{module} is a collection of closely related functions and
% variables. Typical module names include~|int| for integer parameters
% and related functions,~|seq| for sequences and~|box| for boxes.
%
\emph{模块module} 是一组紧密相关的函数和变量的集合。
典型的模块名包括整型参数（以及相关函数）模块~|int|，序列~|seq| 和盒子~|box| 等等。

% Packages providing new programming functionality will add new modules
% as needed; the programmer can choose any unused name, consisting
% of letters only, for a module. In general, the module name and module
% prefix should be related: for example, the kernel module containing
% \texttt{box} functions is called \texttt{l3box}.  Module names and
% programmers' contact details are listed in \pkg{l3prefixes.csv}.
%

提供新程序功能的宏包会按需要添加新的模块；
开发者可以为模块选取任何未使用的名称，但只能包含字母。
一般而言，模块名和模块前缀应当是关联起来的：
例如，包含 \texttt{box} 函数的内核模块叫做 \texttt{l3box}。
模块名和开发者的联系信息在文件 \pkg{l3prefixes.csv} 中。

% The \emph{description} gives more detailed information about the
% function or parameter, and provides a unique name for it.  It should
% consist of letters and, possibly,~|_|~characters. In general, the
% description should use |_| to divide up \enquote{words} or other easy to
% follow parts of the name.  For example, the \LaTeX3 kernel provides
% \cs{if_cs_exist:N} which, as might be expected, tests if a command
% name exists.
%

\emph{描述description} 给出函数或参数的更多详细信息，并确定了唯一的名称。
它应当包含字母和可能的~|_|~字符。
一般而言，描述部分应当使用 |_| 来划分“单词”或者其它部分。
例如，\LaTeX3 内核提供了 \cs{if_cs_exist:N}，
并且正如所预料的那样用于检测一个命令是否存在。

% Where functions for variable manipulation can perform assignments
% either locally or globally, the latter case is indicated by the inclusion of
% a |g| in the second part of the function name. Thus \cs{tl_set:Nn} is a local
% function but \cs{tl_gset:Nn} acts globally. Functions of this type are
% always documented together, and the scope of action may therefore be
% inferred from the presence or absence of a |g|. See the next subsection for
% more detail on variable scope.
%

进行变量操作的函数可以局部或者全局地执行。
后者需要在函数名的第二部分中包含 |g| 标记。
比如 \cs{tl_set:Nn} 是局部函数，而 \cs{tl_gset:Nn} 则是全局的。
这两种类型的函数总是一起文档化，而作用域可以从函数名是否存在 |g| 来推断。
关于变量作用域的信息详见下一小节。

% \subsubsection{Separating private and public material}
\subsubsection{区分私有和公共材料}

%
% One of the issues with the \TeX{} language is that it doesn't support
% name spaces and encapsulation other than by convention. As a result
% nearly every internal command in the \LaTeXe{} kernel has eventually
% be used by extension packages as an entry point for modifications or
% extensions. The consequences of this is that nowadays it is next to
% impossible to change anything in the \LaTeXe{} kernel (even if it is
% clearly just an internal command) without breaking something.
%

\TeX{} 语言的问题之一就是除了通过约定之外不支持名空间（name space）和封装。
结果便是 \LaTeXe{} 内核中的几乎所有内部命令最后都会被外部宏包使用并进行修改或扩展。
造成的后果是现在几乎不可能改动 \LaTeXe{} 内核中的任何东西而不造成破坏
（即便很明显仅仅是个内部命令）。

% In \pkg{expl3} we hope to improve this situation drastically by
% clearly separating public interfaces (that extension packages can use
% and rely on) and private functions and variables (that should not
% appear outside of their module).  There is (nearly) no way to enforce
% this without severe computing overhead, so we implement it only
% through a naming convention, and some support mechanisms.  However, we
% think that this naming convention is easy to understand and to follow,
% so that we are confident that this will adopted and provides the
% desired results.

在 \pkg{expl3} 中我们希望明确地区分公共接口（外部宏包可以使用或依赖）和私有函数/变量（不应当出现在模块之外），
进而可以明显地改善目前这一状况。
而这在没有严重的计算开销条件下几乎不可能实施，
因此我们只是通过命名约定和一些支持机制来实现。
不过，我们认为这种命名约定很容易理解和遵守，
所以有信心认为该约定会被采用并提供想要的结果。

%
% Functions created by a module may either be \enquote{public} (documented
% with a defined interface) or \enquote{private} (to be used only within
% that module, and thus not formally documented). It is important that
% only documented interfaces are used; at the same time, it is necessary to
% show within the name of a function or variable whether it is public
% or private.
%

由模块创建的函数既可以是“公共”的（使用给定接口进行文档说明），
也可以是“私有”的（只在该模块内部使用，因此没有正式文档）。
很重要的一点是，只能使用带有文档的接口；
同时有必要在函数名或变量名中表明是公共的还是私有的。

% To allow clear separation of these two cases, the following convention
% is used. Private functions should be defined with |__| added to the beginning
% of the module name. Thus
% \begin{verbatim}
%   \module_foo:nnn
% \end{verbatim}
% is a public function which should be documented while
% \begin{verbatim}
%   \__module_foo:nnn
% \end{verbatim}
% is private to the module, and should \emph{not} be used outside of that
% module.

使用以下约定来明确地区分这两种情况。
私有函数应当在模块名的开始加上 |__|。因此
\begin{verbatim}
    \module_foo:nnn
\end{verbatim}
是应当进行文档说明的公共函数，而
\begin{verbatim}
    \__module_foo_nnn
\end{verbatim}
是该模块私有的，在该模块外部\emph{不}应当使用。

%
% In the same way, private variables should use two "__" at the start of the
% module name, such that
% \begin{verbatim}
%   \l_module_foo_tl
% \end{verbatim}
% is a public variable and
% \begin{verbatim}
%   \l__module_foo_tl
% \end{verbatim}
% is private.
%

类似地，私有变量应当在模块名开始使用两个 "_"。因此
\begin{verbatim}
    \l_module_foo_tl
\end{verbatim}
是公共变量，而
\begin{verbatim}
    \l__module_foo_tl
\end{verbatim}
是私有的。

% \subsubsection{Using \texttt{@@} and \pkg{l3docstrip} to mark private code}
\subsubsection{使用 \texttt{@@} 和 \pkg{l3docstrip} 来标记私有代码}

%
% The formal syntax for internal functions allows clear separation of public
% and private code, but includes redundant information (every internal function
% or variable includes \texttt{__\meta{module}}). To aid programmers, the
% \pkg{l3docstrip} program introduces the syntax
% \begin{quote}
%   \ttfamily
%   |%<@@=|\meta{module}|>|
% \end{quote}
内部函数的正式语法可以清晰地区分公共和私有代码，
但是同时也会包含冗余信息（每一内部函数或变量都包含 \texttt{__\meta{module}}）。
为了帮助开发者，\pkg{l3docstrip} 项目引入语法
\begin{quote}
    \ttfamily
    |%<@@=|\meta{module}|>|
\end{quote}
% which then allows |@@| (and |_@@| in case of variables) to be used as
% a place holder for \texttt{__\meta{module}} in code. Thus for example
% \begin{verbatim}
%   %<@@=foo>
%   %    \begin{macrocode}
%   \cs_new:Npn \@@_function:n #1
%     ...
%   \tl_new:N \l_@@_my_tl
%   %    \end{macrocode}
% \end{verbatim}
% is converted by \pkg{l3docstrip} to
% \begin{verbatim}
%   \cs_new:Npn \__foo_function:n #1
%     ...
%   \tl_new:N \l__foo_my_tl
% \end{verbatim}
% on extraction. As you can see both |_@@| and |@@| are mapped to
% \texttt{__\meta{module}}, because we think that this helps to
% distinguish variables from functions in the source when the |@@|
% convention is used.
这样允许在代码中使用 |@@|（对于变量的情况是 |_@@|）作为 \texttt{__\meta{module}} 的占位符。
例如，\pkg{l3docstrip} 可以将如下代码
\begin{verbatim}
    %<@@=foo>
    %    \begin{macrocode}
    \cs_new:Npn \@@_function:n #1
     ...
    \tl_new:N \l_@@_my_tl
    %    \end{macrocode}
\end{verbatim}
转化并提取为
\begin{verbatim}
    \cs_new:Npn \__foo_function:n #1
    ...
    \tl_new:N \l__foo_function_my_tl
\end{verbatim}
可以看出，|_@@| 和 |@@| 被映射到 \texttt{__\meta{module}}。
我们认为，在源文件中使用 |@@| 约定有助于区分函数和变量。

%
% \subsubsection{Variables: scope and type}
\subsubsection{变量：作用域和类型}

%
% The \meta{scope} part of the name describes how the variable can be
% accessed.  Variables are classified as local, global or constant.
% This \emph{scope} type appears as a code at the beginning of the name;
% the codes used are:
% \begin{arg-description}
%   \item[c] constants (global variables whose value should not be
%     changed);
%   \item[g] variables whose value should only be set globally;
%   \item[l] variables whose value should only be set locally.
% \end{arg-description}
%

名称中的 \meta{作用域scope} 部分描述了变量是如何获取的。
变量分为局部、全局和常值等类型。
\emph{作用域}类型出现在名称的开始处。
使用的代码为：
\begin{arg-description}
    \item[c] 常值（值不会变化的全局变量）；
    \item[g] 变量的值只应当全局设置；
    \item[l] 变量的值只应当局部设置。
\end{arg-description}

% Separate functions are provided to assign data to local and global
% variables; for example, \cs{tl_set:Nn} and \cs{tl_gset:Nn} respectively
% set the value of a local or global \enquote{token list} variable.
% Note that it is a poor \TeX{} practice to intermix local and global
% assignments to a variable; otherwise you risk exhausting the save
% stack.\footnote{See \emph{The \TeX{}book}, p.\,301, for further
% information.}

使用不同的函数来为局部和全局变量赋值；
例如，\cs{tl_set:Nn} 和 \cs{tl_gset:Nn} 分别设置了局部和全局“记号列表”变量的值。
请注意，给一个变量进行混合的局部和全局赋值是一种很不好的 \TeX{} 做法；
这可能会有耗尽保存的栈容量的风险。\footnote{
更多信息请参考 \emph{The \TeX{}book}，301页。}

%
% The \meta{type} is in the list of available
% \emph{data-types};\footnote{Of course, if a totally new data type is
% needed then this will not be the case. However, it is hoped that only
% the kernel team will need to create new data types.} these include the
% primitive \TeX{} data-types, such as the various registers, but to
% these are added data-types built within the \LaTeX{} programming
% system.
%
\meta{类型type} 的内容位于可用的\emph{数据类型}列表中；\footnote{
当然，例外是需要一个全新的数据类型。
不过我们希望只有内核团队才需要创建新的数据类型。}
这包括 \TeX{} 原始命令中的数据类型，比如各种寄存器。
不过这些已经整合到由 \LaTeX{} 程序系统内部构建的数据类型中。

% The data types in \LaTeX3 are:
% \begin{description}
%   \item[bool]   either true or false (the \LaTeX3 implementation does
%                 not use \tn{iftrue} or \tn{iffalse});
%   \item[box]    box register;
%   \item[clist]  comma separated list;
%   \item[coffin] a \enquote{box with handles} --- a higher-level data
%                 type for carrying out |box| alignment operations;
%   \item[dim]    \enquote{rigid} lengths;
%   \item[fp]     floating-point values;
%   \item[ior]    an input stream (for reading from a file);
%   \item[iow]    an output stream (for writing to a file);
%   \item[int]    integer-valued count register;
%   \item[muskip] math mode \enquote{rubber} lengths;
%   \item[prop]   property list;
%   \item[seq]    sequence: a data-type used to implement lists (with
%                 access at both ends) and stacks;
%   \item[skip]   \enquote{rubber} lengths;
%   \item[str]    \TeX{} strings: a special case of |tl| in which all
%                 characters have category \enquote{other} (catcode~$12$),
%                 other than spaces which are category \enquote{space}
%                 (catcode~$10$);
%   \item[tl]     \enquote{token list variables}: placeholders for token lists.
% \end{description}
% When the \meta{type} and \meta{module} are identical (as often happens in
% the more basic modules) the \meta{module} part is often omitted for
% aesthetic reasons.

\LaTeX3 中的数据类型包括：
\begin{description}
    \item[bool] true 或者 false（\LaTeX3 不使用 \tn{iftrue} 或 \tn{iffalse}）；
    \item[box] 盒子寄存器；
    \item[clist] 逗号分隔列表；
    \item[coffin] “带有句柄的盒子”——一种高层次的数据类型，可以执行 |box| 对齐操作；
    \item[dim] “严格的”长度；
    \item[fp] 浮点数值；
    \item[ior] 输入流（用于文件读取）；
    \item[iow] 输出流（用于文件写入）；
    \item[int] 整型计数寄存器；
    \item[muskip] 数学模式的“弹性”长度；
    \item[prop] 属性列表；
    \item[seq] 序列：用于实现列表（可以获取两端的值）和栈的数据类型；
    \item[skip] “弹性”长度；
    \item[str] \TeX{} 字符串：一种特殊的 |tl|，其中所有的字符类型都是“其它”（类别码为~$12$），
    除了空格的类型是“空格”（类别码为~$10$）；
    \item[tl] “记号列表变量”：用于放置记号列表。
\end{description}
当 \meta{类型type} 和 \meta{模块module} 相同时（通常出现在基本模块中），
\meta{模块module} 部分出于美观原因通常会省略。

%
% The name \enquote{token list} may cause confusion, and so some
% background is useful.  \TeX{} works with tokens and lists of tokens,
% rather than characters. It provides two ways to store these token
% lists: within macros and as token registers (|toks|). The
% implementation in \LaTeX3 means that |toks| are not required, and that
% all operations for storing tokens can use the |tl| variable type.

名称“记号列表”可能会引起困扰，因此介绍一些背景是有必要的。
\TeX{} 处理的是记号和记号列表，而不是字符，
并且提供了两种方式来存储这些记号列表：在宏内部以及记号寄存器（|toks|）。
在 \LaTeX3 中的实现意味着 |toks| 是不需要了，
并且所有存储记号的操作都可以使用 |tl| 变量类型。

%
% Experienced \TeX{} programmers will notice that some of the variable
% types listed are native \TeX{} registers whilst others are not. In
% general, the underlying \TeX{} implementation for a data structure may
% vary but the \emph{documented interface} will be stable. For example,
% the |prop| data type was originally implemented as a |toks|, but
% is currently built on top of the |tl| data structure.
高级 \TeX{} 开发者会注意到，一些变量类型是原生的 \TeX{} 寄存器，而另一些则不是。
一般来说，数据结构的底层实现会变动，而\emph{有文档说明的接口}则是稳定的。
例如，|prop| 数据类型一开始的实现是 |toks|，现在则构建在 |tl| 数据结构之上。

%
% \subsubsection{Variables: guidance}
\subsubsection{变量：说明指导}

%
% Both comma lists and sequences have similar characteristics.
% They both use special delimiters to mark out one entry from the
% next, and are both accessible at both ends. In general, it is
% easier to create comma lists `by hand' as they can be typed
% in directly. User input often takes the form of a comma separated
% list and so there are many cases where this is the obvious
% data type to use. On the other hand, sequences use special internal
% tokens to separate entries. This means that they can be used to
% contain material that comma lists cannot (such as items that may
% themselves contain commas!). In general, comma lists should be
% preferred for creating fixed lists inside programs and for
% handling user input where commas will not occur. On the other
% hand, sequences should be used to store arbitrary lists of
% data.
逗号列表和序列二者具有类似的特征。
它们都使用特殊的定界符来标识各条目，并且都可以从两端读取。
一般来说，“手动”创建逗号列表更容易一些，因为可以直接输入。
用户输入通常采用逗号分隔列表的形式，因此许多情况中这是一种显然可用的数据类型。
另一方面，序列会使用特殊的内部记号来分隔条目。
这意味着它们可以用于逗号列表不能应用的场合（例如每一条目本身可能包含逗号）。
一般而言，逗号列表主要用于创建项目中的固定列表以及处理逗号本身不会出现的用户输入。
同时，序列应当用于存储任意数据列表。

%
% \pkg{expl3} implements stacks using the sequence data structure.
% Thus creating stacks involves first creating a sequence, and
% then using the sequence functions which work in a stack manner
% (\cs{seq_push:Nn}, \emph{etc}.).

\pkg{expl3} 使用序列数据结构实现栈。
因此创建栈会首先创建一个序列，然后使用一些可以满足栈需求的序列函数（例如 \cs{seq_push:Nn} 等）。

%
% Due to the nature of the underlying \TeX{} implementation, it is
% possible to assign values to token list variables and comma lists
% without first declaring them. However, this is \emph{not supported
% behavior}. The \LaTeX3 coding convention is that all variables must
% be declared before use.
由于底层 \TeX{} 实现的固有性质，可以不首先声明就直接赋值给记号列表变量和逗号列表。
然而，我们\emph{不支持}这种行为。
\LaTeX3 代码约定中，所有变量在使用之前都必须先声明。

%
% The \pkg{expl3} package can be loaded with the \texttt{check-declarations}
% option to verify that all variables are declared before use. This has
% a performance implication and is therefore intended for testing during
% development and not for use in production documents.
\pkg{expl3} 宏包可以在导入时加载选项 \texttt{check-declarations}，
用于确认所有的变量在使用前都已声明。
不过这会带来性能的影响，因此主要用于开发中的测试而不是文档生产。

%
% \subsubsection{Functions: argument specifications}
\subsubsection{函数：选项规范}

%
% Function names end with an \meta{arg-spec} after a colon.  This
% gives an indication of the types of argument that a function takes,
% and provides a convenient method of naming similar functions that
% differ only in their argument forms (see the next section for
% examples).
函数名称在冒号后以 \meta{选项规范arg-spec} 结尾。
这给出函数使用的选项类型，
并且提供了一种方便的手段用以给只有选项形式不同的类似函数命名（见下一节的例子）。
%
% The \meta{arg-spec} consists of a (possibly empty) list of letters,
% each denoting one argument of the function. The letter, including
% its case, conveys information about the type of argument required.
\meta{选项规范arg-spec} 包含一个（可能为空的）字母列表，对应于该函数的每一选项。
字母（区分大小写）本身则带有所需选项类型的信息。

%
% All functions have a base form with arguments using one of the
% following argument specifiers:
在所有函数都有的基本形式中，选项使用以下说明符之一：
% \begin{arg-description}
\begin{arg-description}
%   \item[n]  Unexpanded token or braced token list.\\
%     This is a standard \TeX{} undelimited macro argument.
    \item[n] 不展开的记号或者带大括号的记号列表。\\
    这是 \TeX{} 的标准未定界宏选项。
%   \item[N]  Single token (unlike~|n|, the argument must \emph{not} be
%     surrounded by braces).\\
%     A typical example of a command taking an~|N|
%     argument is~|\cs_set|, in which the command being defined must be
%     unbraced.
    \item[N] 单记号（与 |n| 不同，该选项一定\emph{不能}在大括号内）。\\
    带有 |N| 选项的函数中，一个典型的例子是~|\cs_set|，其中被定义的命令一定是不加大括号的。
%   \item[p]  Primitive \TeX{} parameter specification.\\
%     This can be something simple like~|#1#2#3|, but may use arbitrary
%     delimited argument syntax such as: |#1,#2\q_stop#3|. This is used
%     when defining functions.
    \item[p] \TeX{} 原始命令参数规范。\\
    可以简单地取为~|#1#2#3|，但也可以使用任意定界选项语法，比如 |#1,#2\q_stop#3|。
    在定义函数时会使用。
%   \item[T,F]
%     These are special cases of~|n| arguments, used for the
%     true and false code in conditional commands.
    \item[T,F] 这是选项 |n| 的特殊情形，用于条件命令中的真值判断。
% \end{arg-description}
\end{arg-description}
% There are two other specifiers with more general meanings:
另外还有两种意义更广泛的说明符：
% \begin{arg-description}
\begin{arg-description}
%   \item[D] This means: \textbf{Do not use}. This special case is used
%     for \TeX{} primitives.  Programmers outside the kernel team should
%     not use these functions!
    \item[D] 意思是\textbf{不要使用}（\textbf{Do not use}）。
    这一特殊情形用于 \TeX{} 原始命令。
    内核团队之外的开发者不要使用这些函数！
%   \item[w] This means that the argument syntax is \enquote{weird} in that it
%     does not follow any standard rule.  It is used for functions with
%     arguments that take non standard forms: examples are \TeX{}-level
%     delimited arguments and the boolean tests needed after certain
%     primitive |\if|\ldots{} commands.
    \item[w] 选项语法是“奇怪的（weird）”，不遵从任何标准规则。
    这用于带有非标准形式选项的函数：
    相关例子包括 \TeX{} 层面的定界选项以及某些 |\if|\ldots{} 原始命令之后需要的布尔测试。
% \end{arg-description}
\end{arg-description}

%
% In case of |n| arguments that consist of a single token the
% surrounding braces can be omitted in nearly all
% situations---functions that force the use of braces even for single
% token arguments are explicitly mentioned. However, programmers are
% encouraged to always use braces around \texttt{n} arguments, as this
% makes the relationship between function and argument clearer.
在 |n| 选项的情况中，如果只含有单个记号，那么包裹的大括号在几乎所有场合都可以省略
——那些即使是单记号选项也要加上大括号的函数会明确提及。
然而，我们鼓励开发者总是为 \texttt{n} 选项加上大括号，
这可以使得函数和选项的关系更清晰。

%
% Further argument specifiers are available as part of the expansion
% control system.  These are discussed in the next section.
进一步的选项说明符是展开控制系统的一部分，在下一节中讨论。

%
% \section{Expansion control}
\section{展开控制}

%
% Let's take a look at some typical operations one might want to
% perform. Suppose we maintain a stack of open files and we use the
% stack |\g_ior_file_name_seq| to keep track of them (\texttt{ior} is
% the prefix used for the file reading module). The basic operation here
% is to push a name onto this stack which could be done by the operation
% \begin{quote}
%   \cs{seq_gpush:Nn} |\g_ior_file_name_seq {#1}|
% \end{quote}
% where |#1| is the filename. In other words, this operation would
% push the file name as is onto the stack.
让我们看一些可能要进行的典型操作。
假设我们维护一个文件打开的栈，并使用栈 |\g_ior_file_name_seq| 来保持对这些文件的跟踪
（\texttt{ior} 是用于文件读取模块的前缀）。
这里基本操作是将一个文件名推入栈内，可以通过以下操作完成：
\begin{quote}
    \cs{seq_gpush:Nn} |\g_ior_file_name_seq {#1}|
\end{quote}
其中 |#1| 是文件名。即，该操作会将文件名本身推入栈内。

%
% However, we might face a situation where the filename is stored in
% a variable of some sort, say |\l_ior_curr_file_tl|. In this case we
% want to retrieve the value of the variable. If we simply use
% \begin{quote}
%   \cs{seq_gpush:Nn} |\g_ior_file_name_seq| |\l_ior_curr_file_tl|
% \end{quote}
% we do not get the value of the variable pushed onto the stack,
% only the variable name itself. Instead a suitable number of
% \cs{exp_after:wN} would be necessary (together with extra braces) to
% change the order of expansion,\footnote{\cs{exp_after:wN} is
% the \LaTeX3 name for the \TeX{} \tn{expandafter} primitive.} \emph{i.e.}
% \begin{quote}
%   \cs{exp_after:wN}                              \\
%   |   |\cs{seq_gpush:Nn}                         \\
%   \cs{exp_after:wN}                              \\
%   |   \g_ior_file_name_seq|                      \\
%   \cs{exp_after:wN}                              \\
%   |   { \l_ior_curr_file_tl }|
% \end{quote}
然而，我们可能经常会面对的一种场合是，文件名存储在某一变量内，比如 |\l_ior_curr_file_tl|。
此时我们想要检索该变量的值。
如果简单地使用
\begin{quote}
    \cs{seq_gpush:Nn} |\g_ior_file_name_seq| |\l_ior_curr_file_tl|
\end{quote}
那么不会将变量的值推入栈内——推入栈内的仅仅是该变量本身的名称。
取代的办法是，有必要使用一定合适数量的 \cs{exp_after:wN} （以及额外的大括号）
来改变展开的顺序\footnote{
\cs{exp_after:wN} 是 \TeX{} 原始命令 \tn{expandafter} 的 \LaTeX3 名称}，即
\begin{quote}
\cs{exp_after:wN}                              \\
|   |\cs{seq_gpush:Nn}                         \\
\cs{exp_after:wN}                              \\
|   \g_ior_file_name_seq|                      \\
\cs{exp_after:wN}                              \\
|   { \l_ior_curr_file_tl }|
\end{quote}

%
% The above example is probably the simplest case but already shows
% how the code changes to something difficult to understand.
% Furthermore there is an assumption in this: that the storage bin
% reveals its contents after exactly one expansion. Relying on this
% means that you cannot do proper checking plus you have to know
% exactly how a storage bin acts in order to get the correct number
% of expansions.  Therefore \LaTeX3 provides the programmer with a
% general scheme that keeps the code compact and easy to understand.
以上的例子也许是最简单的情形，
但已经展示了代码是如何变得难以理解的。
此外这里还有一个假设：存储的容器正好在一次展开后就完全展示其中的内容。
依赖于这种机制就没法做任何合适的检查，
为了得到正确的展开数量就必须完全搞清楚存储容器是怎样运行的。
因此，\LaTeX3为开发者提供了一般性机制，使得代码紧凑并易于理解。

%
% To denote that some argument to a function needs special treatment one
% just uses different letters in the arg-spec part of the function to
% mark the desired behavior. In the above example one would write
% \begin{quote}
%   \cs{seq_gpush:NV} |\g_ior_file_name_seq \l_ior_curr_file_tl|
% \end{quote}
% to achieve the desired effect. Here the |V| (the second argument)
% is for \enquote{retrieve the value of the variable} before passing it to
% the base function.
为了表达函数的选项需要特殊处理，只要在函数的选项规范部分中使用不同字母来标识需要的行为即可。
在上面的例子中，使用命令
\begin{quote}
    \cs{seq_gpush:NV} |\g_ior_file_name_seq \l_ior_curr_file_tl|
\end{quote}
即可达到想要的效果。
这里第二个选项 |V| 的意思是，在传递给基函数之前“先检索变量的值”。

%
% The following letters can be used to denote special treatment of
% arguments before passing it to the base function:
以下字母可以用于表示选项传递给基函数之前的特殊处理：
% \begin{description}
\begin{description}
%   \item[c] Character string used as a command name.\\ The argument (a
%     token or braced token list) is \emph{fully expanded}; the result
%     must be a sequence of characters which is then used to construct a
%     command name (\emph{via}~\tn{csname} \ldots \tn{endcsname}).  This
%     command name is a single token that is passed to the function as
%     the argument. Hence
    \item[c] 字符（character），作为命令名称使用。\\
    该选项（记号或者带大括号的记号列表）是\emph{完全展开的}；
    其结果必须是字符序列，
    并在之后用于构建命令名称（\emph{通过}~\tn{csname} \ldots \tn{endcsname} 方法）。
    该命令名是单记号，可以作为选项传递给函数。因此
%     \begin{quote}
%       \cs{seq_gpush:cV} |{ g_file_name_seq }| \cs{l_tmpa_tl}
%     \end{quote}
%     is equivalent to
%     \begin{quote}
%       \cs{seq_gpush:NV} |\g_file_name_seq| \cs{l_tmpa_tl}.
%     \end{quote}
    \begin{quote}
        \cs{seq_gpush:cV} |{ g_file_name_seq }| \cs{l_tmpa_tl}
    \end{quote}
    等价于
    \begin{quote}
        \cs{seq_gpush:NV} |\g_file_name_seq| \cs{l_tmpa_tl}
    \end{quote}
%     Full expansion means that (a) the entire
%     argument must be expandable and (b) any variables are
%     converted to their content. So the preceding examples are also
%     equivalent to
    完全展开的含义是 (a) 整个选项必须是可展开的；(b) 任何变量都会转为该变量的内容。
    因此之前的例子也等价于
%     \begin{quote}
%       \cs{tl_new:N} |\g_file_seq_name_tl| \\
%       \cs{tl_gset:Nn} |\g_file_seq_name_tl { g_file_name_seq }| \\
%       \cs{seq_gpush:cV} |{| \cs{tl_use:N} |\g_file_seq_name_tl }| \cs{l_tmpa_tl}.
%     \end{quote}
%     (Token list variables are expandable and we could omit the
%     accessor function \cs{tl_use:N}.  Other variable types require the
%     appropriate \cs{\meta{var}_use:N} functions to be used in this
%     context.)
    \begin{quote}
        \cs{tl_new:N} |\g_file_seq_name_tl| \\
        \cs{tl_gset:Nn} |\g_file_seq_name_tl { g_file_name_seq }| \\
        \cs{seq_gpush:cV} |{| \cs{tl_use:N} |\g_file_seq_name_tl }| \cs{l_tmpa_tl}.
    \end{quote}
    （记号列表变量是可展开的，此时我们可以省略访问函数 \cs{tl_use:N}。
    其它变量类型在这一环境下则需要使用合适的 \cs{<var>_use:N} 函数。）
%   \item[V]  Value of a variable.\\
%     This means that the contents of the register in question is used as the
%     argument, be it an integer, a length-type register, a token list variable
%     or similar. The value is passed to the function as a braced token list.
%     Can be applied to variables which have a \cs{\meta{var}_use:N} function
%     (other than floating points and boxes), 
%     and which therefore deliver a single \enquote{value}.
    \item[V] 变量的值（Value）。\\
    此时，选项会使用寄存器的内容，可以是整型、长度类型的寄存器、记号列表变量等。
    该值作为带大括号的记号列表被传递给函数。
    可以用于带有 \cs{\meta{var}_use:N} 函数（而不是浮点数或盒子），
    从而可以传递单“值”的变量。
%   \item[v] Value of a register, constructed from a character string
%     used as a command name.\\
%     This is a combination of |c| and |V| which first constructs a
%     control sequence from the argument and then passes the value of the
%     resulting register to the function.  
%     Can be applied to variables which have a \cs{\meta{var}_use:N} function (other than
%     floating points and boxes), and which therefore deliver a single
%     \enquote{value}.
    \item[v] 寄存器的值（value），从命令名称的字符串构建而来。\\
    该类型是 |c| 和 |V| 的结合，首先从选项中构造一个控制序列，然后将生成的寄存器的值传递给函数。
    可以用于带有 \cs{\meta{var}_use:N} 函数（而不是浮点数或盒子），
    从而可以传递单值的变量。
%   \item[x]  Fully-expanded token or braced token list.\\
%     This means that the argument is expanded as in the replacement
%     text of an~\tn{edef}, and the expansion is passed to the function as
%     a braced token list.  Expansion takes place until only unexpandable
%     tokens are left.  |x|-type arguments cannot be nested.
    \item[x] 完全展开（expand）的记号或者带大括号的记号列表。\\
    该选项会像用 \tn{edef} 一样展开，然后展开值作为带大括号的记号列表传递给函数。
    展开会一直执行，直到遇到不可展开的记号。
    |x| 类型的选项不可以嵌套。
%   \item[o]  One-level-expanded token or braced token list.\\
%     This means that the argument is expanded one level, as by
%     \tn{expandafter}, and the expansion is passed to the function as a
%     braced token list.  Note that if the original argument is a braced
%     token list then only the first token in that list is expanded.
%     In general, using \texttt{V} should be preferred to using
%     \texttt{o} for simple variable retrieval.
    \item[o] 展开一层（one-level）的记号或带大括号的记号列表。\\
    这说明该选项会像 \tn{expandafter} 那样展开一层，
    然后展开值作为带大括号的记号列表传递给函数。
    请注意，如果原始的参数是带大括号的记号列表，
    那么只有列表中的第一个记号会被展开。
    一般来说，对于简单的变量检索使用类型 \texttt{V} 比使用 \texttt{o} 更好一些。
%   \item[f] Expanding the first token recursively in a braced token
%     list.\\ Almost the same as the |x| type except here the token list
%     is expanded fully until the first unexpandable token is found and
%     the rest is left unchanged. Note that if this function finds a
%     space at the beginning of the argument it gobbles it and does not
%     expand the next token.
    \item[f] 在带有大括号的记号列表中递归地展开第一个（first）记号。\\
    和 |x| 类型几乎相同，不同之处在于这里记号列表被完全展开，
    直到发现第一个不可展开的记号，而剩下的部分则保持不变。
    请注意，如果该函数在选项的一开始发现空格，那么会吞掉该空格，而不会展开接下来的记号。
% \end{description}
\end{description}

%
% \subsection{Simpler means better}
\subsection{越简单越好}

%
% Anyone who programs in \TeX{} is frustratingly familiar with the
% problem of arranging that arguments to functions are suitably expanded
% before the function is called.  To illustrate how expansion control
% can bring instant relief to this problem we shall consider two
% examples copied from \texttt{latex.ltx}.
如何安排函数的选项，使得选项在调用函数之前能够在合适的位置展开，
这是每一个 \TeX{} 开发者都经常面对的头疼问题。
我们从 \texttt{latex.ltx} 中选取两个例子，
进而说明展开控制机制能够对这一问题带来立竿见影的效果。

%
% \begin{verbatim}
%        \global\expandafter\let
%              \csname\cf@encoding \string#1\expandafter\endcsname
%              \csname ?\string#1\endcsname
% \end{verbatim}
% This first piece of code is in essence simply a global \tn{let} whose
% two arguments firstly have to be constructed before \tn{let} is
% executed. The |#1| is a control sequence name such as
% |\textcurrency|. The token to be defined is obtained by
% concatenating the characters of the current font encoding stored in
% |\cf@encoding|, which has to be fully expanded, and the name of the
% symbol. The second token is the same except it uses the default
% encoding |?|. The result is a mess of interwoven \tn{expandafter}
% and \tn{csname} beloved of all \TeX{} programmers, and the code is
% essentially unreadable.
\begin{verbatim}
    \global\expandafter\let
          \csname\cf@encoding \string#1\expandafter\endcsname
          \csname ?\string#1\endcsname
\end{verbatim}
第一份代码片段本质上只是个全局的 \tn{let} 命令，
它的两个选项必须在 \tn{let} 命令执行之前首先进行构造。
|#1| 是一个控制序列，比如 |\textcurrency|。
将当前字体编码字符（存储在|\cf@encoding|，需要完全展开）和符号名称连接起来，
并获得第一个选项需要定义的记号。
而第二个选项中的记号也是相同的过程，只不过使用默认编码 |?|。
而结果就是一团 \tn{expandafter} 和 \tn{csname} 交织在一起
（当然 \TeX{} 程序员都很喜欢用），导致代码本质上是不可读的。

%
% Using the conventions and functionality outlined here, the task would
% be achieved with code such as this:
% \begin{verbatim}
%   \cs_gset_eq:cc
%     { \cf@encoding \token_to_str:N  #1 } { ? \token_to_str:N #1 }
% \end{verbatim}
% The command \cs{cs_gset_eq:cc} is a global~\tn{let} that generates
% command names out of both of its arguments before making the
% definition. This produces code that is far more readable and more
% likely to be correct first time. (\cs{token_to_str:N} is the \LaTeX3
% name for \tn{string}.)
使用这里提出的约定和功能，这项任务可以通过如下代码来实现：
\begin{verbatim}
    \cs_gset_eq:cc
     { \cf@encoding \token_to_str:N  #1 } { ? \token_to_str:N #1 }
\end{verbatim}
命令 \cs{cs_gset_eq:cc} 是全局的 \tn{let}，
可以在定义之前先生成两个选项的命令名称。
这样代码的可读性要好得多，出了问题也可以第一时间修改。
（\cs{token_to_str:N} 是 \tn{string} 的 \LaTeX3 名称。）

%
% Here is the second example.
% \begin{verbatim}
%   \expandafter
%     \in@
%   \csname sym#3%
%     \expandafter
%       \endcsname
%     \expandafter
%       {%
%     \group@list}%
% \end{verbatim}
% This piece of code is part of the definition of another function. It
% first produces two things: a token list, by expanding |\group@list| once;
% and a token whose name comes from~`|sym#3|'.  Then the function~\cs{in@}
% is called and this tests if its first argument occurs in the token list
% of its second argument.
这里是第二个例子：
\begin{verbatim}
    \expandafter
        \in@
    \csname sym#3%
        \expandafter
            \endcsname
        \expandafter
            {%
        \group@list}%
\end{verbatim}
这份代码是另外一个函数定义的一部分。
它首先做两件事情：
通过展开一次 |\group@list| 获得一个记号列表，
从 |sym#3| 获取一个记号的名称。
然后调用函数 \cs{in@} 并检测第一个选项是否在第二个选项代表的记号列表中。

%
% Again we can improve enormously on the code.  First we shall rename
% the function~\cs{in@}, which tests if its first argument appears
% within its second argument, according to our conventions.  Such a
% function takes two normal \enquote{\texttt{n}} arguments and operates
% on token lists: it might reasonably be named |\tl_test_in:nn|.  Thus
% the variant function we need would be defined with the appropriate
% argument types and its name would be |\tl_test_in:cV|.  Now this code
% fragment would be simply:
% \begin{verbatim}
%   \tl_test_in:cV { sym #3 } \group@list
% \end{verbatim}
% This code could be improved further by using a sequence |\l_group_seq|
% rather than the bare token list |\group@list|.  Note that, in addition
% to the lack of \tn{expandafter}, the space after the~|}| is
% silently ignored since all white space is ignored in this programming
% environment.
同样地，我们可以极大改进这份代码。
首先根据约定，我们要重命名函数~\cs{in@}，
该函数的功能是检测第一个选项是否出现在第二个选项内。
这样的函数有两个正常的“|n|”选项，并操作记号列表：
因此很自然地可以命名为 |\tl_test_in:nn|。
我们需要的函数变体需要定义合适的选项类型，因此名称为 |\tl_test_in:cV|。
现在该代码片段可以简化为
\begin{verbatim}
    \tl_test_in:cV { sym #3 } \group@list
\end{verbatim}
可以使用序列 |\l_group_seq| 来代替裸记号列表 |\group@list|，
从而进一步改进代码。
请注意，除了不需要 \tn{expandafter} 之外，
右大括号 |}| 之后的空格也会自动忽略，
这是因为该程序环境中所有的空格都会被忽略。

%
% \subsection{New functions from old}
\subsection{函数推陈出新}

%
% For many common functions the \LaTeX3 kernel provides variants
% with a range of argument forms, and similarly it is expected that
% extension packages providing new functions will make them available in
% all the commonly needed forms.
对于很多常用函数，\LaTeX3 内核提供了针对不同选项形式的一系列函数变种。
类似地，我们也希望扩展宏包提供的新函数对于常见选项类型都是可用的。

%
% However, there will be occasions where it is necessary to construct a
% new such variant form; therefore the expansion module provides a
% straightforward mechanism for the creation of functions with any
% required argument type, starting from a function that takes \enquote{normal}
% \TeX{} undelimited arguments.
然而构造新的函数变种形式有时候还是有必要的。
为此，扩展模块提供了一种直接的机制，
可以从带有“常规的”\TeX{} 未定界选项的函数开始，创建带有任何选项类型的函数

%
% To illustrate this let us suppose you have a \enquote{base function}
% |\demo_cmd:Nnn| that takes three normal arguments, and that you need
% to construct the variant |\demo_cmd:cnx|, for which the first argument
% is used to construct the \emph{name} of a command, whilst the third
% argument must be fully expanded before being passed to
% |\demo_cmd:Nnn|.
% To produce the variant form from the base form, simply use this:
% \begin{verbatim}
%   \cs_generate_variant:Nn \demo_cmd:Nnn { cnx }
% \end{verbatim}
% This defines the variant form so that you can then write, for example:
% \begin{verbatim}
%   \demo_cmd:cnx { abc } { pq } { \rst \xyz }
% \end{verbatim}
% rather than \ldots\ well, something like this!
% \begin{verbatim}
%   \def \tempa {{pq}}%
%   \edef \tempb {\rst \xyz}%
%   \expandafter
%     \demo@cmd:nnn
%   \csname abc%
%     \expandafter
%       \expandafter
%     \expandafter
%         \endcsname
%     \expandafter
%       \tempa
%     \expandafter
%       {%
%     \tempb
%       }%
% \end{verbatim}
为了阐述这一点，假设有一个带有三个常规选项的“基函数”|\demo_cmd:Nnn|。
现在想要构造变种  |\demo_cmd:cnx|，其中第一个选项用于构造命令的“名称”，
而第三个选项必须在传给 |\demo_cmd:Nnn| 之前完全展开。
只要简单地使用如下代码就可以从基本形式生成变种形式：
\begin{verbatim}
    \cs_generate_variant:Nn \demo_cmd:Nnn { cnx }
\end{verbatim}
然后变种函数就可以使用了，比如：
\begin{verbatim}
    \demo_cmd:cnx { abc } { pq } { \rst \xyz }
\end{verbatim}
否则的话……就要使用如下可怕的代码！
\begin{verbatim}
    \def \tempa {{pq}}%
    \edef \tempb {\rst \xyz}%
    \expandafter
        \demo@cmd:nnn
    \csname abc%
        \expandafter
            \expandafter
        \expandafter
            \endcsname
        \expandafter
            \tempa
        \expandafter
            {%
        \tempb
            }%
\end{verbatim}

%
% Another example: you may wish to declare a function
% |\demo_cmd_b:xcxcx|, a variant of an existing function
% |\demo_cmd_b:nnnnn|, that fully
% expands arguments 1,~3 and~5, and produces commands to pass as
% arguments 2 and~4 using~\tn{csname}.
% The definition you need is simply
% \begin{verbatim}
%   \cs_generate_variant:Nn \demo_cmd_b:nnnnn { xcxcx }
% \end{verbatim}
另一个例子：你想要根据已有函数 |\demo_cmd_b:nnnnn| 来声明变种函数 |\demo_cmd_b:xcxcx|，
使得可以完全展开选项1、3、5，然后使用 \tn{csname} 生成命令并传递选项2、4。
定义这样的函数仅需要：
\begin{verbatim}
    \cs_generate_variant:Nn \demo_cmd_b:nnnnn { xcxcx }
\end{verbatim}

%
% This extension mechanism is written so that if the same new form of
% some existing command is implemented by two extension packages then the
% two definitions are identical and thus no conflict occurs.
扩展机制的目的在于，如果两个不同的扩展宏包都对某个已有命令进行新变种的实现，
那么这两个定义是相同的，不会造成冲突。

%
% \section{The distribution}
\section{发布}

%
% At present, the \pkg{expl3} modules are designed to be loaded on top
% of \LaTeXe{}. In time, a \LaTeX3 format will be produced based on this
% code. This allows the code to be used in \LaTeXe{} packages \emph{now}
% while a stand-alone \LaTeX3 is developed.
目前，\pkg{expl3} 模块被设计为在 \LaTeXe{} 之上导入。
之后会基于这些代码生成 \LaTeX3 格式。
因此，\emph{目前}可以在 \LaTeXe{} 宏包中使用这些代码，而独立的 \LaTeX3 还在开发中。

%
% \begin{bfseries}
%   While \pkg{expl3} is still experimental, the bundle is now regarded
%   as broadly stable. The syntax conventions and functions provided
%   are now ready for wider use. There may still be changes to some
%   functions, but these will be minor when compared to the scope of
%   \pkg{expl3}.
% \end{bfseries}
\begin{bfseries}
    虽然 \pkg{expl3} 宏集仍然处于实验性质阶段，不过可以认为已经相当稳定了。
    提供的语法约定和函数也可以广泛应用。
    当然某些函数可能还有有改动，但与整个 \pkg{expl3} 相比只是一些小改动。
\end{bfseries}

%
% New modules will be added to the distributed version of \pkg{expl3}
% as they reach maturity. At present, the \pkg{expl3} bundle consists
% of a number of modules, most of which are loaded by including the
% line:
% \begin{verbatim}
%   \RequirePackage{expl3}
% \end{verbatim}
% in a \LaTeXe{} package, class or other file. The \pkg{expl3} modules
% regarded as stable, and therefore suitable for basing real code on,
% are as follows:
新模块在成熟稳定后会加到 \pkg{expl3} 的发行版本中。
目前 \pkg{expl3} 宏集已经包含了众多模块，
在 \LaTeXe{} 宏包、文档类以及其它文件中包含如下一行代码即可导入绝大部分模块：
\begin{verbatim}
    \RequirePackage{expl3}
\end{verbatim}
\pkg{expl3} 中的模块可以认为是稳定的，
可以适合在其基础上构建实际代码，
具体如下：

%
% \begin{description}
\begin{description}
%   \providecommand\explpkg[2]{\item[#1]#2}
    \providecommand\explpkg[2]{\item[#1]#2}
%   \explpkg{l3basics}{
%     This contains the basic definition modules used
%     by the other packages.
%   }
    \explpkg{l3basics}{
        包含其它宏包使用的基本定义模块。}
%   \explpkg{l3box}{
%     Primitives for dealing with boxes.
%   }
    \explpkg{l3box}{
        处理盒子的原始命令。}
%   \explpkg{l3clist}{
%     Methods for manipulating comma-separated token lists.
%   }
    \explpkg{l3clist}{
        操作逗号分隔记号列表的方法。}
%   \explpkg{l3coffins}{
%     Augmented box constructs for alignment operations.
%   }
    \explpkg{l3coffins}{
        补充的盒子对齐操作。}
%   \explpkg{l3expan}{
%     This is the argument expansion module discussed earlier in this
%     document.
%   }
    \explpkg{l3expan}{
        本文档之前讨论的选项展开模块。}
%   \explpkg{l3int}{
%     This implements the integer data-type \texttt{int}.
%   }
    \explpkg{l3int}{
        实现整型数据类型 \texttt{int}。}
%   \explpkg{l3keys}{
%     For processing lists of the form
%     \texttt{\{ key1=val1 , key2=val2 \}}, intended to work
%     as a \LaTeX3 version of \pkg{xkeyval}/\pkg{kvoptions}, although
%     with input syntax more like that of \pkg{pgfkeys}.
%   }
    \explpkg{l3keys}{
        处理具有形式 \texttt{\{ key1=val1 , key2=val2 \}} 的列表，
        本模块的目的是 \LaTeX3 版本的 \pkg{xkeyval}/\pkg{kvoptions} 宏包，
        不过输入的语法与 \pkg{pgfkeys} 更相似。}
%   \explpkg{l3msg}{
%     Communicating with the user: includes low-level hooks to allow
%     messages to be filtered (higher-level interface for filtering
%     to be written!).
%   }
    \explpkg{l3msg}{
        用户交互：包括一些用于过滤信息的低层次的钩子（高层次的过滤信息接口还在开发）。}
%   \explpkg{l3names}{
%     This sets up the basic naming scheme and renames all
%     the \TeX{} primitives.
%   }
    \explpkg{l3names}{
        设置基本命名机制，并且重命名了所有的 \TeX{} 原始命令。}
%   \explpkg{l3prg}{
%     Program control structures such as boolean data type |bool|, generic
%     do-while loops, and conditional flow.
%   }
    \explpkg{l3prg}{
        程序控制的一些结构，例如布尔变量类型 |bool|、一般的 do-while 循环以及条件流。}
%   \explpkg{l3prop}{
%     This implements the data-type for \enquote{property lists} that are used, in
%     particular, for storing key/value pairs.
%   }
    \explpkg{l3prop}{
        实现了“属性列表”的数据类型，主要用于存储键值对。}
%   \explpkg{l3quark}{
%     A \enquote{quark} is a command that is defined to expand to
%     itself!  Therefore they must never be expanded as this would generate an
%     infinite recursion; they do however have many uses, \emph{e.g.}~as
%     special markers and delimiters within code.
%   }
    \explpkg{l3quark}{
        “夸克（quark）”是定义为可以展开到自己的命令！
        因此绝对不可以被展开，否则会产生无穷递归。
        不过它们确实有很多应用，比如作为代码内特别的标识符或定界符。\footnote{
            这个概念疑似从 quine 变形而来，后者指能够生成自己的程序代码，见 \url{https://en.wikipedia.org/wiki/Quine_(computing)}
            ——译注}}
%   \explpkg{l3seq}{
%     This implements data-types such as queues and stacks.
%   }
    \explpkg{l3seq}{
        实现了队列和栈等数据类型。}
%   \explpkg{l3skip}{
%     Implements the \enquote{rubber length} datatype \texttt{skip}, the
%     \enquote{rigid length} datatype |dim|, and the math mode
%     \enquote{rubber length} datatype \texttt{muskip}.
%   }
    \explpkg{l3skip}{
        实现了“弹性长度”数据类型 \texttt{skip}，“严格长度”数据类型 |dim|，
        以及数学模式“弹性长度”数据类型 \texttt{muskip}。}
%   \explpkg{l3tl}{
%     This implements a basic data-type, called a \textit{token-list
%     variable} (|tl var.|), used for storing named token lists: these are
%     \TeX{} macros with no arguments.
%   }
    \explpkg{l3tl}{
        实现了基本数据类型 \emph{记号列表变量}（|tl var.|），用于存储命名记号列表：
        不带参数的 \TeX{} 宏。}
%   \explpkg{l3token}{
%     Analysing token lists and token streams, including peeking ahead to
%     see what's coming next and inspecting tokens to detect which kind
%     they are.
%   }
    \explpkg{l3token}{
        分析记号列表和记号流，包括查看接下来的记号以及检测相关类型。}
% \end{description}
\end{description}

%
% \section{Moving from \LaTeXe{} to \LaTeX3}
\section{从 \LaTeXe{} 到 \LaTeX3}

%
% To help programmers to use \LaTeX3 code in existing \LaTeXe{} package,
% some short notes on making the change are probably desirable.
% Suggestions for inclusion here are welcome! Some of the following
% is concerned with code, and some with coding style.
为了帮助开发者在现有的 \LaTeXe{} 宏包中使用 \LaTeX3 代码，
给出一些关于相关改变的简要注记是值得的。
这里总的建议就是欢迎使用！
以下的注记中一些是关于代码的，另一些则关于代码风格。

%
% \begin{itemize}
\begin{itemize}
%   \item \pkg{expl3} is mainly focused on programming. This means that
%     some areas still require the use of \LaTeXe{} internal macros.
%     For example, you may well need \tn{@ifpackageloaded}, as there
%     is currently no native \LaTeX3 package loading module.
    \item \pkg{expl3} 主要关注于程序设计。所以某些领域仍然需要 \LaTeXe{} 的内部宏。
    例如你可能需要 \tn{@ifpackageloaded}，因为当前 \LaTeX3 没有原生的宏包导入模块。
%   \item User level macros should be generated using the mechanism
%     available in the \pkg{xparse} package, which is part of the
%     \texttt{l3package} bundle, available from CTAN or the \LaTeX3 SVN
%     repository.
    \item 用户水平的宏应当使用 \pkg{xparse} 宏包中的机制生成，这是 \texttt{l3package} 宏集的一部分，
    可以从 CTAN 或者 \LaTeX3 SVN 仓库获得。
%   \item At an internal level, most functions should be generated
%     \tn{long} (using \cs{cs_new:Npn}) rather than \enquote{short} (using
%     \cs{cs_new_nopar:Npn}).
   \item 在内部层面上，大部分函数应当生成为 \tn{long}（使用 \cs{cs_new:Npn}）
    而不是“short”（使用 \cs{cs_new_nopar:Npn}）。
%   \item Where possible, declare all variables and functions (using
%     \cs{cs_new:Npn}, \cs{tl_new:N}, etc.) before use.
    \item 尽可能在使用之前声明所有变量和函数（使用 \cs{cs_new:Npn}, \cs{tl_new:N} 等）。
%   \item Prefer \enquote{higher-level} functions over \enquote{lower-level},
%     where possible. So for example use \cs{cs_if_exist:N(TF)} and not
%     \cs{if_cs_exist:N}.
    \item 尽可能选择“高层次”函数而不是“低层次”函数。
    例如使用 \cs{cs_if_exist:N(TF)}  而不是 \cs{if_cs_exist:N}。
%   \item Use space to make code readable. In general, we recommend
%     a layout such as:
%     \begin{verbatim}
%       \cs_new:Npn \foo_bar:Nn #1#2
%         {
%           \cs_if_exist:NTF #1
%             { \__foo_bar:n {#2} }
%             { \__foo_bar:nn {#2} { literal } }
%         }
%     \end{verbatim}
%     where spaces are used around |{| and |}| except for isolated
%     |#1|, |#2|, \emph{etc.}
    \item 使用空格以增加代码的可读性。一般我们推荐以下的风格：
    \begin{verbatim}
        \cs_new:Npn \foo_bar:Nn #1#2
            {
                \cs_if_exist:NTF #1
                    { \__foo_bar:n {#2} }
                    { \__foo_bar:nn {#2} { literal } }
            }
    \end{verbatim}
    在  |{| 和 |}| 周围使用空格，除非是单独的 |#1|, |#2| 等。
%   \item Put different code items on separate lines: readability is
%     much more useful than compactness.
    \item 将不同的代码项目分行放置：可读性比紧凑性有用的多。
%   \item Use long, descriptive names for functions and variables,
%     and for auxiliary functions use the parent function name plus
%     |aux|, |auxi|, |auxii| and so on.
    \item 在函数和变量中使用长的描述性的名称，
    而对于辅助函数则使用父函数加上 |aux|, |auxi|, |auxii| 等前后缀。
%   \item If in doubt, ask the team via the LaTeX-L list: someone will
%     soon get back to you!
    \item 如果有任何疑问，
    通过 \href{http://news.gmane.org/group/gmane.comp.tex.latex.latex3}{LaTeX-L} 列表咨询团队：
    相关人员会很快回复！
% \end{itemize}
\end{itemize}

%
% \section{Load-time options for \pkg{expl3}}
\section{宏包 \pkg{expl3} 的载入时选项}

%
% To support code authors, the \pkg{expl3} package for \LaTeXe{} includes
% a small number of load-time options. These all work in a key--value
% sense, recognising the \texttt{true} and \texttt{false} values. Giving
% the option name alone is equivalent to using the option with the
% \texttt{true} value.
为了支持代码开发者，\LaTeXe{} 宏包 \pkg{expl3} 包含了少量导入时选项。
这些选项都以键值形式给出，并可以识别 \texttt{true} 和 \texttt{false} 值。
只给出选项名等价于该选项使用 \texttt{true} 值。

%
% \DescribeOption{check-declarations}
% All variables used in \LaTeX3 code should be declared. This is enforced
% by \TeX{} for variable types based on \TeX{} registers, but not for those
% which are constructed using macros as the underlying storage system. The
% \texttt{check-declarations} option enables checking for all variable
% assignments, issuing an error if any variables are assigned without being
% initialised.  See also \cs{debug_on:n} \texttt{\{check-declarations\}}
% in \pkg{l3candidates} for finer control.
\DescribeOption{check-declarations}
所有 \LaTeX3 代码中的变量都必须声明。
对于基于 \TeX{} 寄存器的变量类型，这由 \TeX{} 强制执行；
而出于底层的存储原因，对于使用宏构造的变量则不保证。
选项 \texttt{check-declarations} 则确保对于所有变量分配都开启检查，
如果任何变量没有初始化则报错。
另见 \pkg{l3candidates} 中的 \cs{debug_on:n} \texttt{\{check-declarations\}}，
可以进行更精细的控制。

%
% \DescribeOption{log-functions}
% The \texttt{log-functions} option is used to enable recording of every new
% function name in the \texttt{.log} file. This is useful for debugging
% purposes, as it means that there is a complete list of all functions
% created by each module loaded (with the exceptions of a very small number
% required by the bootstrap code for \LaTeX3).  See also \cs{debug_on:n}
% \texttt{\{log-functions\}} in \pkg{l3candidates} for finer control.
\DescribeOption{log-functions}
该选项用于在 \texttt{.log} 文件中开启每一新函数名的记录。
这会有一份由导入模块创建的全体函数列表
（例外是 \LaTeX3 的bootstrap代码需要的一小部分）。
另见 \pkg{l3candidates} 中的\cs{debug_on:n} \texttt{\{log-functions\}}，
可以进行更精细的控制。

%
% \DescribeOption{enable-debug}
% To allow more localized checking and logging than provided by
% \texttt{check-declarations} and \texttt{log-functions}, \pkg{expl3}
% provides a few \cs[no-index]{debug_\ldots{}} functions (described
% elsewhere) that turn on the corresponding checks within a group.
% These functions can only be used if \pkg{expl3} is loaded with the
% \texttt{enable-debug} option.
\DescribeOption{enable-debug}
除了 \texttt{check-declarations} 和 \texttt{log-functions} 之外，
\pkg{expl3} 还提供了一些 \cs[no-index]{debug_\ldots{}} 函数（描述另见他处）
在一个组内开启相应检查，这样可以允许更多的本地化检查和日志记录。
只有当 \pkg{expl3} 导入时带有 \texttt{enable-debug} 选项时才可以使用这些函数。

%
% \DescribeOption{driver}
% Selects the driver to be used for color, graphics and related operations that
% are driver-dependent. Options available are
\DescribeOption{driver}
选择颜色、图像和其它驱动相关操作所需要的驱动类型。可用选项有：
% \begin{itemize}[font = \texttt]
\begin{itemize}[font = \texttt]
%   \item[auto] Let \LaTeX3 determine the correct driver. With DVI output, this
%     selects the \texttt{dvips} back-end for \pdfTeX{} and \LuaTeX{}, and
%     \texttt{dvipdfmx} for \pTeX{} and \upTeX{}.  This is the standard setting.
    \item[auto] 让 \LaTeX3 自己确定正确的驱动。
    输出 DVI 时，会为 \pdfTeX{} 和 \LuaTeX{} 选择 \texttt{dvips} 后端，
    而对于 \pTeX{} 和 \upTeX{} 则会选择 \texttt{dvipdfmx}。
    这是标准设置。
%   \item[latex2e] Use the \pkg{graphics} package to select the driver, rather
%     than \LaTeX3 code.
    \item[latex2e] 使用 \pkg{graphics} 宏包代替 \LaTeX3 代码来选择驱动。
%   \item[dvips] Use the \texttt{dvips} driver.
    \item[dvips] 使用 \texttt{dvips} 驱动。
%   \item[dvipdfmx] Use the \texttt{dvipdfmx} driver.
    \item[dvipdfmx] 使用 \texttt{dvipdfmx} 驱动。
%   \item[dvisvgm] Use the \texttt{dvisvgm} driver.
    \item[dvisvgm] 使用 \texttt{dvisvgm} 驱动。
%   \item[pdfmode] Use the \texttt{pdfmode} driver (direct PDF output from
%     \pdfTeX{} or \LuaTeX{}).
    \item[pdfmode] 使用 \texttt{pdfmode} 驱动（\pdfTeX{} 或 \LuaTeX{} 的直接PDF输出）。
%   \item[xdvipdfmx] Use the \texttt{xdvipdfmx} driver (\XeTeX{} only).
    \item[xdvipdfmx] 使用 \texttt{xdvipdfmx} 驱动（仅用于 \XeTeX{}）。
% \end{itemize}
\end{itemize}

%
% \section{Using \pkg{expl3} with formats other than \LaTeXe{}}
\section{在 \LaTeXe{} 之外使用 \pkg{expl3}}

%
% As well as the \LaTeXe{} package \pkg{expl3}, there is also a
% \enquote{generic} loader for the code, \texttt{expl3.tex}. This may be
% loaded using the plain \TeX{} syntax
% \begin{verbatim}
%   \input expl3-generic %
% \end{verbatim}
% This enables the programming layer to work with the other formats.
% As no options are available loading in this way, the \enquote{native}
% drivers are automatically used. If this \enquote{generic} loader is
% used with \LaTeXe{} the code automatically switches to the appropriate
% package route.
在 \LaTeXe{} 宏包 \pkg{expl3} 之外，还有一种“一般的”方法可以导入该代码：\texttt{expl3.tex}。
这可以在 plain\TeX{} 语法中导入：
\begin{verbatim}
    \input expl3-generic %
\end{verbatim}
这可以在其它格式下进行程序设计层面的有关工作。
使用这种方法时没有可用的选项，所以会自动选择“原生的”驱动。
如果在 \LaTeXe{} 中使用这种“一般的”导入方法，
那么代码会自动切换到合适的宏包路径上去。

%
% After loading the programming layer using the generic interface, the
% commands \cs{ExplSyntaxOn} and \cs{ExplSyntaxOff} and the code-level
% functions and variables detailed in \pkg{interface3} are available.
% Note that other \LaTeXe{} packages \emph{using} \pkg{expl3} are not
% loadable: package loading is dependent on the \LaTeXe{} package-management
% mechanism.
使用一般接口导入程序设计层面后，
可以使用命令 \cs{ExplSyntaxOn}、\cs{ExplSyntaxOff}、
以及 \pkg{interface3} 中详细介绍的代码层面上的函数和变量。
请注意不会导入其它\emph{使用} \pkg{expl3} 的 \LaTeXe{} 宏包：
宏包导入取决于 \LaTeXe{} 的宏包管理机制。

%
% \section{Engine/primitive requirements}
\section{引擎和原始命令需求}

%
% To use \pkg{expl3} and the higher level packages provided by the
% team, the minimal set of primitive requirements is currently
为了使用本团队提供的 \pkg{expl3} 和高层面宏包，
目前原始命令需求的最小集合是
% \begin{itemize}
\begin{itemize}
%    \item All of those from \TeX90.
    \item \TeX90 中的全部。
%    \item All of those from \eTeX{} \emph{excluding} |\TeXXeTstate|,
%      |\beginL|, |\beginR|, |\endL| and |\endR| (\emph{i.e.}~excluding
%      \TeX{}-\kern0pt-\reflectbox{\TeX{}}).
    \item \eTeX{} 中的全部，\emph{除了} |\TeXXeTstate|, |\beginL|, |\beginR|, |\endL|, |\endR|
    （即，除了 \TeX{}-\kern0pt-\reflectbox{\TeX{}}）。
%    \item Functionality equivalent to the \pdfTeX{} primitive
%      |\pdfstrcmp|.
    \item 等价于 \pdfTeX{} 原始命令 |\pdfstrcmp| 的功能。
% \end{itemize}
\end{itemize}
% Any engine which defines |\pdfoutput| (\emph{i.e.}~allows direct production
% of a PDF file without a DVI intermediate) must also provide |\pdfcolorstack|,
% |\pdfliteral|, |\pdfmatrix|, |\pdfrestore| and |\pdfsave| or equivalent
% functionality. Fully Unicode engines must provide a method for producing
% character tokens in an expandable manner.
任何定义了 |\pdfoutput|（即，允许不经中间的DVI直接生成 PDF文件）
的引擎必须同时提供 |\pdfcolorstack|, |\pdfliteral|, |\pdfmatrix|, |\pdfrestore|, |\pdfsave| 或者等价的功能。
Unicode引擎必须提供以可展开方式生成字符记号的方法。

%
% \begin{itemize}
%    \item \pdfTeX{} v1.40 or later.
%    \item \XeTeX{} v0.99992 or later.
%    \item \LuaTeX{} v0.76 or later.
%    \item e-(u)\pTeX{} mid-2012 or later.
% \end{itemize}
实际中，以下引擎可以满足这些需求
\begin{itemize}
    \item \pdfTeX{} v1.40 或之后版本。
    \item \XeTeX{} v0.99992 或之后版本。
    \item \LuaTeX{} v0.70 或之后版本。
    \item e-(u)p\TeX{} 2012 中期或之后版本。
\end{itemize}

%
% Additional modules beyond the core of \pkg{expl3} may require additional
% primitives. In particular, third-party authors may significantly
% extend the primitive coverage requirements.
\pkg{expl3} 内核之外的其它模块可能需要额外的原始命令。
特别要指出的是，第三方作者可能会明显地提高对原始命令覆盖的需求。

%
% \section{The \LaTeX3 Project}
\section{\LaTeX3 项目组}
\LaTeX3 的开发由 \LaTeX3 项目组实施。成员名单略。

%
% Development of \LaTeX3 is carried out by The \LaTeX3 Project. Over time,
% the membership of this team has naturally varied. Currently, the members
% are
% \begin{itemize}
%   \item Johannes Braams
%   \item David Carlisle
%   \item Robin Fairbairns
%   \item Morten H{\o}gholm
%   \item Bruno Le Floch
%   \item Thomas Lotze
%   \item Frank Mittelbach
%   \item Will Robertson
%   \item Chris Rowley
%   \item Rainer Sch{\"o}pf
%   \item Joseph Wright
% \end{itemize}
% while former members are
% \begin{itemize}
%   \item Michael Downes
%   \item Denys Duchier
%   \item Alan Jeffrey
%   \item Martin Schr{\"o}der
% \end{itemize}
%

\begin{thebibliography}{1}

\bibitem{A-W:K-TB}
 Donald E Knuth
 \newblock \emph{The \TeX{}book}.
 \newblock Addison-Wesley, Reading, Massachusetts, 1984.

\bibitem{A-W:GMS94}
 Goossens, Mittelbach and Samarin.
 \newblock \emph{ The \LaTeX{} Companion}.
 \newblock Addison-Wesley, Reading, Massachusetts, 1994.

\bibitem{A-W:LLa94}
 Leslie Lamport.
 \newblock \emph{\LaTeX{}: A Document Preparation System}.
 \newblock Addison-Wesley, Reading, Massachusetts, second edition, 1994.

\bibitem{tub:MR97-1}
 Frank Mittelbach and Chris Rowley.
 \newblock \enquote{The \LaTeX3 Project}.
 \newblock \emph{TUGboat},
 Vol.\,18, No.\,3, pp.\,195--198, 1997.

\end{thebibliography}


\end{document}




